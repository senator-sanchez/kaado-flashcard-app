---
globs: *.dart
description: Dart coding standards and best practices
---

# Dart Coding Standards

## Basic Principles
- Use English for all code and documentation
- Always declare the type of each variable and function (parameters and return value)
  - Avoid using `any` or `dynamic`
  - Create necessary types
- Write concise, technical Dart code with accurate examples
- Use functional and declarative programming patterns where appropriate
- Prefer composition over inheritance
- Don't leave blank lines within a function
- One export per file

## Nomenclature
- Use PascalCase for classes
- Use camelCase for variables, functions, and methods
- Use underscore_case for file and directory names
- Use UPPERCASE for environment variables
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError, canDelete)
- Start each function with a verb
- Use complete words instead of abbreviations and correct spelling
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations: i, j for loops; err for errors; ctx for contexts; req, res, next for middleware

## Functions
- Write short functions with a single purpose (less than 20 instructions)
- Name functions with a verb and something else
  - If it returns a boolean, use isX, hasX, canX, etc.
  - If it doesn't return anything, use executeX, saveX, etc.
- Use arrow syntax for simple functions and methods
- Prefer expression bodies for one-line getters and setters
- Avoid nesting blocks by:
  - Early checks and returns
  - Extraction to utility functions
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting
- Use default parameter values instead of checking for null or undefined
- Reduce function parameters using RO-RO pattern:
  - Use an object to pass multiple parameters
  - Use an object to return results
  - Declare necessary types for input arguments and output
- Use a single level of abstraction

## Data & Classes
- Don't abuse primitive types; encapsulate data in composite types
- Avoid data validations in functions; use classes with internal validation
- Prefer immutability for data
  - Use `final` and `const` where appropriate
  - Use Freezed for immutable state classes and unions
- Include createdAt, updatedAt, and isDeleted fields in database tables
- Follow SOLID principles
- Prefer composition over inheritance
- Declare interfaces to define contracts
- Write small classes with a single purpose
  - Less than 200 instructions
  - Less than 10 public methods
  - Less than 10 properties

## Error Handling
- Use exceptions to handle errors you don't expect
- If you catch an exception, it should be to:
  - Fix an expected problem
  - Add context
  - Otherwise, use a global handler
- Use AsyncValue for proper error handling and loading states
- Implement proper error handling for external operations (API, database)